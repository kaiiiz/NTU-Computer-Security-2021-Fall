int _IO_new_file_overflow(FILE *f, int ch) {
    if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
    {
        f->_flags |= _IO_ERR_SEEN;
        __set_errno(EBADF);
        return EOF;
    }
    /* If currently reading or no buffer allocated. */
    if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) {
        /* Allocate a buffer if needed. */
        if (f->_IO_write_base == NULL) {
            _IO_doallocbuf(f);
            _IO_setg(f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
        }
        /* Otherwise must be currently reading.
	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
	 logically slide the buffer forwards one block (by setting the
	 read pointers to all point at the beginning of the block).  This
	 makes room for subsequent output.
	 Otherwise, set the read pointers to _IO_read_end (leaving that
	 alone, so it can continue to correspond to the external position). */
        if (__glibc_unlikely(_IO_in_backup(f))) {
            size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
            _IO_free_backup_area(f);
            f->_IO_read_base -= MIN(nbackup,
                                    f->_IO_read_base - f->_IO_buf_base);
            f->_IO_read_ptr = f->_IO_read_base;
        }

        if (f->_IO_read_ptr == f->_IO_buf_end)
            f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
        f->_IO_write_ptr = f->_IO_read_ptr;
        f->_IO_write_base = f->_IO_write_ptr;
        f->_IO_write_end = f->_IO_buf_end;
        f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;

        f->_flags |= _IO_CURRENTLY_PUTTING;
        if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
            f->_IO_write_end = f->_IO_write_ptr;
    }
    if (ch == EOF)
        return _IO_do_write(f, f->_IO_write_base,
                            f->_IO_write_ptr - f->_IO_write_base);
    if (f->_IO_write_ptr == f->_IO_buf_end) /* Buffer is really full */
        if (_IO_do_flush(f) == EOF)
            return EOF;
    *f->_IO_write_ptr++ = ch;
    if ((f->_flags & _IO_UNBUFFERED) || ((f->_flags & _IO_LINE_BUF) && ch == '\n'))
        if (_IO_do_write(f, f->_IO_write_base,
                         f->_IO_write_ptr - f->_IO_write_base) == EOF)
            return EOF;
    return (unsigned char)ch;
}